{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BetterCRUD","text":"BetterCRUD <p> A better CRUD library for FastAPI. <sub>FastAPI CRUD routing library based on class view, you can control everything</sub> </p> <p> </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Fully Async, Synchronization is not supported</li> <li>Less boilerplate code</li> <li>Configuring static type support</li> <li>More flexible custom configuration\uff0cLess invasive</li> <li>Compatible with both class views and functional views</li> <li>Rich filter, paging, and sorting support</li> <li>Automated relationship support, query, auto-build and update</li> <li>Extensible custom backend</li> </ul>"},{"location":"#default-routes","title":"Default Routes","text":"Route Method Description /resource GET Get Many /resource/{id} GET Get One /resource POST Create One /resource/bulk POST Create Many /resource/{id} PUT Update One /resource/{ids}/bulk PUT Update Many /resource/{ids} DELETE Delete Many"},{"location":"#minimal-example","title":"Minimal Example","text":"<p>Warning</p> <p>Prerequisites,Prepare our db, Only asynchronous mode is supported,aiomysql or aiosqlite</p> db.py<pre><code>from sqlalchemy.orm import DeclarativeBase, declared_attr\nfrom typing import AsyncGenerator\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.pool import NullPool\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nDATABASE_URL = \"sqlite+aiosqlite:///crud.db\"\n\nclass MappedBase(DeclarativeBase):\n    @declared_attr.directive\n    def __tablename__(cls) -&gt; str:\n        return cls.__name__.lower()\n\n\nclass Base(MappedBase):\n    __abstract__ = True\n\n\nengine = create_async_engine(\n    DATABASE_URL,\n    echo=False,\n    poolclass=NullPool\n)\n\nSessionLocal = sessionmaker(\n    autocommit=False,\n    autoflush=False,\n    bind=engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\n\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with SessionLocal() as session:\n        yield session\n\n\nasync def init_db():\n    async with engine.begin() as conn:\n        await conn.run_sync(MappedBase.metadata.create_all)\n</code></pre> <p>First Define Your Model And Schema</p> model.py<pre><code>from sqlalchemy import String, Integer, ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom .db import Base\n\n\nclass Pet(Base):\n    __tablename__ = \"pet\"\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n    name: Mapped[str] = mapped_column(String(100))\n    description: Mapped[str] = mapped_column(String(100))\n</code></pre> schema.py<pre><code>from typing import Optional, List\nfrom pydantic import BaseModel\n\n\nclass PetBase(BaseModel):\n    name: Optional[str] = None\n    description: Optional[str] = None\n\n\nclass PetPublic(PetBase):\n    id: int\n\n\nclass PetCreate(PetBase):\n    pass\n\n\nclass PetUpdate(PetBase):\n    pass\n</code></pre> <p>Next we need to create a service:</p> service.py<pre><code>from better_crud.service.sqlalchemy import SqlalchemyCrudService\nfrom .model import Pet\n\n\nclass PetService(SqlalchemyCrudService[Pet]):\n    def __init__(self):\n        super().__init__(Pet)\n</code></pre> <p>Next we need to define the controller and decorate it with the crud decorator Sure the controller is just a normal class,The crud decorator gives it super powers</p> controller.py<pre><code>from fastapi import APIRouter, Depends\nfrom better_crud import crud\nfrom .schema import PetCreate, PetUpdate, PetPublic\nfrom .service import PetService\n\npet_router = APIRouter()\n\n\n@crud(\n    pet_router,\n    dto={\n        \"create\": PetCreate,\n        \"update\": PetUpdate\n    },\n    serialize={\n        \"base\": PetPublic,\n    }\n)\nclass PetController():\n    service: PetService = Depends(PetService)\n</code></pre> <p>Next we can register router to the fastapi routing system</p> main.py<pre><code>from better_crud import BetterCrudGlobalConfig\nfrom fastapi import FastAPI\nfrom contextlib import asynccontextmanager\nfrom .db import get_session, init_db\n\nBetterCrudGlobalConfig.init(\n    backend_config={\n        \"sqlalchemy\": {\n            \"db_session\": get_session\n        }\n    }\n)\n\n\n@asynccontextmanager\nasync def lifespan(_: FastAPI):\n    await init_db()\n    # Shutdown\n    yield\n\napp = FastAPI(lifespan=lifespan)\n\n\ndef register_router():\n    from app.controller import pet_router\n    app.include_router(pet_router, prefix=\"/pet\")\n\n\nregister_router()\n</code></pre> <p>Congratulations, your first CRUD route has been created\uff01</p> <p></p>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"changelog/","title":"BetterCRUD Changelog","text":""},{"location":"changelog/#introduction","title":"Introduction","text":"<p>The Changelog documents all notable changes made to BetterCRUD. This includes new features, bug fixes, and improvements. It's organized by version and date, providing a clear history of the library's development.</p>"},{"location":"changelog/#006-feb-16-2025","title":"[0.0.6] - Feb 16, 2025","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Sorting can't use the Related Table alias field</li> <li>Under certain conditions, queries using alias tables are invalid</li> </ul>"},{"location":"changelog/#005-feb-12-2025","title":"[0.0.5] - Feb 12, 2025","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Add model alias to query,avoid Not unique table/alias errors</li> </ul>"},{"location":"changelog/#usage-example","title":"Usage Example","text":"<pre><code>from sqlalchemy.orm import aliased\n\nModifierUser = aliased(User)\n\nclass Post(PostBase, table=True):\n    __tablename__ = \"post\"\n    id: Optional[int] = Field(default=None, primary_key=True)\n    creater_user_id: Optional[int] = Field(\n        default=None, foreign_key=\"user.id\"\n    )\n    modifier_user_id: Optional[int] = Field(\n        default=None, foreign_key=\"user.id\"\n    )\n\n    creater_user: User = Relationship(\n        sa_relationship_kwargs={\"uselist\": False, \"lazy\": \"noload\", \"foreign_keys\": \"[Post.creater_user_id]\"})\n\n    modifier_user: User = Relationship(\n        sa_relationship_kwargs={\"uselist\": False, \"lazy\": \"noload\", \"foreign_keys\": \"[Post.modifier_user_id]\"})\n\n@crud(\n    router,\n    dto={\"create\": PostCreate, \"update\": PostUpdate},\n    serialize={\"base\": PostPublic},\n    query={\n        \"joins\": {\n            \"creater_user\": {\n                \"select\": True,\n                \"join\": True\n            },\n            \"modifier_user\": {\n                \"select\": True,\n                \"join\": True,\n                \"alias\": ModifierUser\n            }\n        },\n    }\n)\nclass PostController():\n    service: PostService = Depends(PostService)\n</code></pre>"},{"location":"installing/","title":"Installing","text":""},{"location":"installing/#requirements","title":"Requirements","text":"<ul> <li>Python: Version 3.9 or newer.</li> <li>FastAPI: BetterCRUD is built to work with FastAPI, so having FastAPI in your project is essential.</li> <li>SQLAlchemy: Version 2.0.30 or newer. BetterCRUD uses SQLAlchemy for database operations.</li> <li>Pydantic: Version 2.7.3 or newer. BetterCRUD leverages Pydantic models for data validation and serialization.</li> </ul>"},{"location":"installing/#installing","title":"Installing","text":"<p>To install, just run:</p> <pre><code>pip install better-crud\n</code></pre> <p>Or, if using poetry:</p> <pre><code>poetry add better-crud\n</code></pre>"},{"location":"quick-start/","title":"Quick-Start","text":""},{"location":"quick-start/#minimal-example","title":"Minimal Example","text":"<p>Warning</p> <p>Prerequisites,Prepare our db, Only asynchronous mode is supported,aiomysql or aiosqlite</p> db.py<pre><code>from sqlalchemy.orm import DeclarativeBase, declared_attr\nfrom typing import AsyncGenerator\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.pool import NullPool\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nDATABASE_URL = \"sqlite+aiosqlite:///crud.db\"\n\nclass MappedBase(DeclarativeBase):\n    @declared_attr.directive\n    def __tablename__(cls) -&gt; str:\n        return cls.__name__.lower()\n\n\nclass Base(MappedBase):\n    __abstract__ = True\n\n\nengine = create_async_engine(\n    DATABASE_URL,\n    echo=False,\n    poolclass=NullPool\n)\n\nSessionLocal = sessionmaker(\n    autocommit=False,\n    autoflush=False,\n    bind=engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\n\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with SessionLocal() as session:\n        yield session\n\n\nasync def init_db():\n    async with engine.begin() as conn:\n        await conn.run_sync(MappedBase.metadata.create_all)\n</code></pre> <p>First Define Your Model And Schema</p> model.py<pre><code>from sqlalchemy import String, Integer, ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom .db import Base\n\n\nclass Pet(Base):\n    __tablename__ = \"pet\"\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n    name: Mapped[str] = mapped_column(String(100))\n    description: Mapped[str] = mapped_column(String(100))\n</code></pre> schema.py<pre><code>from typing import Optional, List\nfrom pydantic import BaseModel\n\n\nclass PetBase(BaseModel):\n    name: Optional[str] = None\n    description: Optional[str] = None\n\n\nclass PetPublic(PetBase):\n    id: int\n\n\nclass PetCreate(PetBase):\n    pass\n\n\nclass PetUpdate(PetBase):\n    pass\n</code></pre> <p>Next we need to create a service:</p> service.py<pre><code>from better_crud.service.sqlalchemy import SqlalchemyCrudService\nfrom .model import Pet\n\n\nclass PetService(SqlalchemyCrudService[Pet]):\n    def __init__(self):\n        super().__init__(Pet)\n</code></pre> <p>Next we need to define the controller and decorate it with the crud decorator Sure the controller is just a normal class,The crud decorator gives it super powers</p> controller.py<pre><code>from fastapi import APIRouter, Depends\nfrom better_crud import crud\nfrom .schema import PetCreate, PetUpdate, PetPublic\nfrom .service import PetService\n\npet_router = APIRouter()\n\n\n@crud(\n    pet_router,\n    dto={\n        \"create\": PetCreate,\n        \"update\": PetUpdate\n    },\n    serialize={\n        \"base\": PetPublic,\n    }\n)\nclass PetController():\n    service: PetService = Depends(PetService)\n</code></pre> <p>Next we can register router to the fastapi routing system</p> main.py<pre><code>from better_crud import BetterCrudGlobalConfig\nfrom fastapi import FastAPI\nfrom contextlib import asynccontextmanager\nfrom .db import get_session, init_db\n\nBetterCrudGlobalConfig.init(\n    backend_config={\n        \"sqlalchemy\": {\n            \"db_session\": get_session\n        }\n    }\n)\n\n\n@asynccontextmanager\nasync def lifespan(_: FastAPI):\n    await init_db()\n    # Shutdown\n    yield\n\napp = FastAPI(lifespan=lifespan)\n\n\ndef register_router():\n    from app.controller import pet_router\n    app.include_router(pet_router, prefix=\"/pet\")\n\n\nregister_router()\n</code></pre> <p>And it's all done, just go to /docs and the crud endpoints are created.</p>"},{"location":"sqlmodel/","title":"Using BetterCRUD with SQLModel","text":"<p>Since SQLModel combines the functionality of sqlalchemy and pydantic, all you need to do is replace the model with SQLModel</p> <p>Warning</p> <p>Prerequisites,Prepare our db, Only asynchronous mode is supported,aiomysql or aiosqlite</p> db.py<pre><code>from typing import AsyncGenerator\nfrom sqlmodel import SQLModel\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom sqlalchemy.pool import NullPool\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nDATABASE_URL = \"sqlite+aiosqlite:///crud.db\"\n\nengine = create_async_engine(\n    DATABASE_URL,\n    echo=False,\n    poolclass=NullPool\n)\n\nSessionLocal = sessionmaker(\n    autocommit=False,\n    autoflush=False,\n    bind=engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\n\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with SessionLocal() as session:\n        yield session\n\n\nasync def init_db():\n    async with engine.begin() as conn:\n        await conn.run_sync(SQLModel.metadata.create_all)\n</code></pre> <p>First Define your SQLModel model</p> model.py<pre><code>from typing import Optional, List\nfrom sqlmodel import Field, SQLModel, Relationship\n\n\nclass PetBase(SQLModel):\n    name: Optional[str] = None\n    description: Optional[str] = Field(default=None)\n\n\nclass Pet(PetBase, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n\n\nclass PetPublic(PetBase):\n    id: Optional[int]\n\n\nclass PetCreate(PetBase):\n    pass\n\n\nclass PetUpdate(PetBase):\n    pass\n</code></pre> <p>Next we need to create a service:</p> service.py<pre><code>from better_crud.service.sqlalchemy import SqlalchemyCrudService\nfrom .model import Pet\n\n\nclass PetService(SqlalchemyCrudService[Pet]):\n    def __init__(self):\n        super().__init__(Pet)\n</code></pre> <p>Next we need to define the controller and decorate it with the crud decorator Sure the controller is just a normal class,The crud decorator gives it super powers</p> controller.py<pre><code>from fastapi import APIRouter, Depends\nfrom better_crud import crud\nfrom .model import PetCreate, PetUpdate, PetPublic\nfrom .service import PetService\n\npet_router = APIRouter()\n\n\n@crud(\n    pet_router,\n    dto={\n        \"create\": PetCreate,\n        \"update\": PetUpdate\n    },\n    serialize={\n        \"base\": PetPublic,\n    }\n)\nclass PetController():\n    service: PetService = Depends(PetService)\n</code></pre> <p>Next we can register router to the fastapi routing system</p> main.py<pre><code>from better_crud import BetterCrudGlobalConfig\nfrom fastapi import FastAPI\nfrom contextlib import asynccontextmanager\nfrom .db import get_session, init_db\n\nBetterCrudGlobalConfig.init(\n    backend_config={\n        \"sqlalchemy\": {\n            \"db_session\": get_session\n        }\n    }\n)\n\n\n@asynccontextmanager\nasync def lifespan(_: FastAPI):\n    await init_db()\n    # Shutdown\n    yield\n\napp = FastAPI(lifespan=lifespan)\n\n\ndef register_router():\n    from app.controller import pet_router\n    app.include_router(pet_router, prefix=\"/pet\")\n\n\nregister_router()\n</code></pre> <p>And it's all done, just go to /docs and the crud endpoints are created.</p>"},{"location":"usage/global_config/","title":"Global Config","text":"<p>Some configurations are for the route level, of course, you can also configure it globally, otherwise each route needs to be reconfigured once. The design is designed to be configured globally, and can be overridden at the routing level</p> <pre><code>from better_crud import BetterCrudGlobalConfig\n\nBetterCrudGlobalConfig.init(**config)\n\n@classmethod\ndef init(\n    cls,\n    *,\n    backend_config: Optional[BackendConfigDict] = None,\n    query: Optional[GlobalQueryOptionsDict] = {},\n    routes: Optional[RoutesModelDict] = {},\n    delim_config: Optional[QueryDelimOptionsDict] = {},\n    soft_deleted_field_key: Optional[str] = None,\n    action_map: Optional[Dict[str, str]] = None,\n    page_schema: Optional[AbstractPage] = Page,\n    response_schema: Optional[AbstractResponseModel] = None\n) -&gt; None:\n</code></pre> <p>Warning</p> <p>So in order to apply the global configuration you need to execute init before importing the routing class. This is because python decorators are executed when we declare the class, not when we create a new class instance. So in your main.py:</p> main.py<pre><code>BetterCrudGlobalConfig.init(\n    backend_config={\n        \"sqlalchemy\": {\n            \"db_session\": get_session\n        }\n    }\n)\napp = FastAPI(lifespan=lifespan)\n\n\ndef register_router():\n    from app.controller import pet_router\n    app.include_router(pet_router, prefix=\"/pet\")\n\n\nregister_router()\n</code></pre> <ul> <li>backend_config</li> <li>1. Define Your db_session</li> <li>2. Custom Your Backend</li> <li>query</li> <li>routes</li> <li>1. Set global dependencies</li> <li>2. Only Get Many,Get One route</li> <li>3. Exclude Create Many route</li> <li>delim_config</li> <li>soft_deleted_field_key</li> <li>action_map</li> <li>page_schema</li> <li>response_schema</li> </ul>"},{"location":"usage/global_config/#backend_config","title":"backend_config","text":"<pre><code>DBSessionFactory = Callable[..., Union[AsyncGenerator[Any, None], Any]]\n\nclass SqlalchemyBackendDict(TypedDict):\n    db_session: DBSessionFactory\n\nBackendType = Literal[\n    \"sqlalchemy\",\n    \"custom\"\n]\n\nclass BackendConfigDict(TypedDict):\n    backend: BackendType\n    sqlalchemy: SqlalchemyBackendDict\n</code></pre>"},{"location":"usage/global_config/#1-define-your-db_session","title":"1. Define Your db_session","text":"<p>db_session is an asynchronous generator function that returns type AsyncSession</p> <pre><code>from sqlalchemy.ext.asyncio import AsyncSession\n\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with SessionLocal() as session:\n        yield session\n\nBetterCrudGlobalConfig.init(\n    backend_config={\n        \"sqlalchemy\": {\n            \"db_session\": get_session\n        }\n    }\n)\n</code></pre> <p>If you use fastapi_sqlalchemy</p> <pre><code>from fastapi_sqlalchemy import db\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    yield db.session\n</code></pre>"},{"location":"usage/global_config/#2-custom-your-backend","title":"2. Custom Your Backend","text":"<p>Currently, only the backend of sqlalchemy is implemented Of course, you can implement your own backend by setting backend to custom, For example, here's how</p> <p><pre><code>from better_crud import BetterCrudGlobalConfig\n\nBetterCrudGlobalConfig.init(\n    backend_config={\n        \"backend\":\"custom\"\n    }\n)\n</code></pre> Your backend class inherits AbstractCrudService and implements its abstract methods</p> <p>The business service inherits from it service.py<pre><code>from better_crud.service.sqlalchemy import SqlalchemyCrudService\nfrom .model import Pet\n\n\nclass PetService(YourCustomCrudService[Pet]):\n    def __init__(self):\n        super().__init__(Pet)\n</code></pre></p>"},{"location":"usage/global_config/#query","title":"query","text":"<p>Configuration of some global query parameters <pre><code>class GlobalQueryOptionsDict(TypedDict, total=False):\n    soft_delete: Optional[bool] = False\n    sort: Optional[List[QuerySortDict]] = None\n    allow_include_deleted: Optional[bool] = False\n\nclass QuerySortDict(TypedDict):\n    field: str\n    sort: Literal[\"ASC\", \"DESC\"]\n</code></pre></p> <p>GlobalQueryOptionsDict</p> Name Type Description soft_delete bool Decide whether soft delete is enabled sort List[QuerySortDict] Sort configuration and support for multiple fields allow_include_deleted bool Query whether data that has been soft-deleted is allowed <p>QuerySortDict</p> Name Type Description field str Sort fields sort Literal[\"ASC\", \"DESC\"] ASC ascending and DESC descending"},{"location":"usage/global_config/#routes","title":"routes","text":"Name Type Description dependencies Sequence[params.Depends] Set the depends of the route only List[RoutesEnumType] Only contain routes exclude List[RoutesEnumType] Routes that need to be excluded get_many RouteOptionsDict Route config for get_many get_one RouteOptionsDict Route config for get_one create_one RouteOptionsDict Route config for create_one create_many RouteOptionsDict Route config for create_many update_one RouteOptionsDict Route config for update_one update_many RouteOptionsDict Route config for update_many delete_many RouteOptionsDict Route config for delete_many <pre><code>RoutesEnumType = Literal[\n    \"get_many\",\n    \"get_one\",\n    \"create_one\",\n    \"create_many\",\n    \"update_one\",\n    \"update_many\",\n    \"delete_many\"\n]\n\nclass RouteOptionsDict(TypedDict, total=False):\n    dependencies: Optional[Sequence[params.Depends]] = None\n    summary: Optional[str] = None\n</code></pre> <p>RouteOptionsDict</p> Name Type Description dependencies Sequence[params.Depends] Set the depends of the route summary str Set the summary of the swagger"},{"location":"usage/global_config/#1-set-global-dependencies","title":"1. Set global dependencies","text":"<pre><code>from fastapi.security import HTTPBearer\nfrom fastapi import Depends\nJWTDepend = Depends(HTTPBearer())\n\nBetterCrudGlobalConfig.init(\n    routes={\n        \"dependencies\":[JWTDepend],\n    }\n)\n</code></pre>"},{"location":"usage/global_config/#2-only-get-manyget-one-route","title":"2. Only Get Many,Get One route","text":"<pre><code>from fastapi.security import HTTPBearer\nfrom fastapi import Depends\nJWTDepend = Depends(HTTPBearer())\n\nBetterCrudGlobalConfig.init(\n    routes={\n        \"only\":[\"get_many\",\"get_one\"]\n    }\n)\n</code></pre>"},{"location":"usage/global_config/#3-exclude-create-many-route","title":"3. Exclude Create Many route","text":"<pre><code>from fastapi.security import HTTPBearer\nfrom fastapi import Depends\nJWTDepend = Depends(HTTPBearer())\n\nBetterCrudGlobalConfig.init(\n    routes={\n        \"exclude\":[\"create_many\"]\n    }\n)\n</code></pre>"},{"location":"usage/global_config/#delim_config","title":"delim_config","text":"<p>Splitter config <pre><code>class QueryDelimOptionsDict(TypedDict, total=False):\n    delim: Optional[str] = \"||\"\n    delim_str: Optional[str] = \",\"\n</code></pre> delim is used to split multiple query criteria</p> <ul> <li>?filter=field||condition||value</li> <li>?filter=user_name||$eq||alice</li> <li>?filter=age||$gt||20</li> </ul> <p>delim_str is used to split order field and sort by</p> <ul> <li>?order=age,ASC</li> <li>?order=id,DESC</li> </ul>"},{"location":"usage/global_config/#soft_deleted_field_key","title":"soft_deleted_field_key","text":""},{"location":"usage/global_config/#action_map","title":"action_map","text":""},{"location":"usage/global_config/#page_schema","title":"page_schema","text":""},{"location":"usage/global_config/#response_schema","title":"response_schema","text":""}]}