{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BetterCRUD","text":"BetterCRUD <p> A better CRUD library for FastAPI. <sub>FastAPI CRUD routing library based on class view, you can control everything</sub> </p> <p> </p> <p>Documentation: https://bigrivi.github.io/better_crud/</p> <p>Source Code: https://github.com/bigrivi/better_crud</p> <p>BetterCRUD is a library that can quickly generate CRUD routes for you without any intrusion to your code. You can still control everything. When you are troubled by a large number of repeated CRUD routes, I believe it can help you and bring you a different development experience, saving you a lot of time and allowing you to focus more on business logic.</p> <p>BetterCRUD is reliable, fully tested, and used in project production environments.</p> <p>BetterCRUD is a way to dynamically generate routes by combining your model with the crud decorator,I believe bring you a different development experience</p> <pre><code>@crud(\n    router,\n    dto={\n        \"create\": PetCreate,\n        \"update\": PetUpdate\n    },\n    serialize={\n        \"base\": PetPublic,\n    },\n    **other_options\n)\nclass PetController():\n    service: PetService = Depends(PetService)\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Fully Async, Synchronization is not supported</li> <li>Less boilerplate code</li> <li>Configuring static type support</li> <li>More flexible custom configuration\uff0cLess invasive</li> <li>Compatible with both class views and functional views</li> <li>Rich filter, pagination, and sorting support</li> <li>Automated relationship support, query and storage</li> <li>Extensible custom backend</li> </ul>"},{"location":"#default-routes","title":"Default Routes","text":"Route Method Description /resource GET Get Many /resource/{id} GET Get One /resource POST Create One /resource/bulk POST Create Many /resource/{id} PUT Update One /resource/{ids}/bulk PUT Update Many /resource/{ids} DELETE Delete Many"},{"location":"#minimal-example","title":"Minimal Example","text":"<p>Warning</p> <p>Prerequisites,Prepare our db, Only asynchronous mode is supported,aiomysql or aiosqlite</p> db.py<pre><code>from sqlalchemy.orm import DeclarativeBase, declared_attr\nfrom typing import AsyncGenerator\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.pool import NullPool\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nDATABASE_URL = \"sqlite+aiosqlite:///crud.db\"\n\nclass MappedBase(DeclarativeBase):\n    @declared_attr.directive\n    def __tablename__(cls) -&gt; str:\n        return cls.__name__.lower()\n\n\nclass Base(MappedBase):\n    __abstract__ = True\n\n\nengine = create_async_engine(\n    DATABASE_URL,\n    echo=False,\n    poolclass=NullPool\n)\n\nSessionLocal = sessionmaker(\n    autocommit=False,\n    autoflush=False,\n    bind=engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\n\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with SessionLocal() as session:\n        yield session\n\n\nasync def init_db():\n    async with engine.begin() as conn:\n        await conn.run_sync(MappedBase.metadata.create_all)\n</code></pre> <p>First Define Your Model And Schema</p> model.py<pre><code>from sqlalchemy import String, Integer, ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom .db import Base\n\n\nclass Pet(Base):\n    __tablename__ = \"pet\"\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n    name: Mapped[str] = mapped_column(String(100))\n    description: Mapped[str] = mapped_column(String(100))\n</code></pre> schema.py<pre><code>from typing import Optional, List\nfrom pydantic import BaseModel\n\n\nclass PetBase(BaseModel):\n    name: Optional[str] = None\n    description: Optional[str] = None\n\n\nclass PetPublic(PetBase):\n    id: int\n\n\nclass PetCreate(PetBase):\n    pass\n\n\nclass PetUpdate(PetBase):\n    pass\n</code></pre> <p>Next we need to create a service:</p> service.py<pre><code>from better_crud.service.sqlalchemy import SqlalchemyCrudService\nfrom .model import Pet\n\n\nclass PetService(SqlalchemyCrudService[Pet]):\n    def __init__(self):\n        super().__init__(Pet)\n</code></pre> <p>Next we need to define the controller and decorate it with the crud decorator Sure the controller is just a normal class,The crud decorator gives it super powers</p> controller.py<pre><code>from fastapi import APIRouter, Depends\nfrom better_crud import crud\nfrom .schema import PetCreate, PetUpdate, PetPublic\nfrom .service import PetService\n\npet_router = APIRouter()\n\n\n@crud(\n    pet_router,\n    dto={\n        \"create\": PetCreate,\n        \"update\": PetUpdate\n    },\n    serialize={\n        \"base\": PetPublic,\n    }\n)\nclass PetController():\n    service: PetService = Depends(PetService)\n</code></pre> <p>Next we can register router to the fastapi routing system</p> main.py<pre><code>from better_crud import BetterCrudGlobalConfig\nfrom fastapi import FastAPI\nfrom contextlib import asynccontextmanager\nfrom .db import get_session, init_db\n\nBetterCrudGlobalConfig.init(\n    backend_config={\n        \"sqlalchemy\": {\n            \"db_session\": get_session\n        }\n    }\n)\n\n\n@asynccontextmanager\nasync def lifespan(_: FastAPI):\n    await init_db()\n    # Shutdown\n    yield\n\napp = FastAPI(lifespan=lifespan)\n\n\ndef register_router():\n    from app.controller import pet_router\n    app.include_router(pet_router, prefix=\"/pet\")\n\n\nregister_router()\n</code></pre> <p>Congratulations, your first CRUD route has been created\uff01</p> <p></p>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"changelog/","title":"BetterCRUD Changelog","text":""},{"location":"changelog/#introduction","title":"Introduction","text":"<p>The Changelog documents all notable changes made to BetterCRUD. This includes new features, bug fixes, and improvements. It's organized by version and date, providing a clear history of the library's development.</p>"},{"location":"changelog/#006-feb-16-2025","title":"[0.0.6] - Feb 16, 2025","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Sorting can't use the Related Table alias field</li> <li>Under certain conditions, queries using alias tables are invalid</li> </ul>"},{"location":"changelog/#005-feb-12-2025","title":"[0.0.5] - Feb 12, 2025","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Add model alias to query,avoid Not unique table/alias errors</li> </ul>"},{"location":"changelog/#usage-example","title":"Usage Example","text":"<pre><code>from sqlalchemy.orm import aliased\n\nModifierUser = aliased(User)\n\nclass Post(PostBase, table=True):\n    __tablename__ = \"post\"\n    id: Optional[int] = Field(default=None, primary_key=True)\n    creater_user_id: Optional[int] = Field(\n        default=None, foreign_key=\"user.id\"\n    )\n    modifier_user_id: Optional[int] = Field(\n        default=None, foreign_key=\"user.id\"\n    )\n\n    creater_user: User = Relationship(\n        sa_relationship_kwargs={\"uselist\": False, \"lazy\": \"noload\", \"foreign_keys\": \"[Post.creater_user_id]\"})\n\n    modifier_user: User = Relationship(\n        sa_relationship_kwargs={\"uselist\": False, \"lazy\": \"noload\", \"foreign_keys\": \"[Post.modifier_user_id]\"})\n\n@crud(\n    router,\n    dto={\"create\": PostCreate, \"update\": PostUpdate},\n    serialize={\"base\": PostPublic},\n    query={\n        \"joins\": {\n            \"creater_user\": {\n                \"select\": True,\n                \"join\": True\n            },\n            \"modifier_user\": {\n                \"select\": True,\n                \"join\": True,\n                \"alias\": ModifierUser\n            }\n        },\n    }\n)\nclass PostController():\n    service: PostService = Depends(PostService)\n</code></pre>"},{"location":"installing/","title":"Installing","text":""},{"location":"installing/#requirements","title":"Requirements","text":"<ul> <li>Python: Version 3.9 or newer.</li> <li>FastAPI: BetterCRUD is built to work with FastAPI, so having FastAPI in your project is essential.</li> <li>SQLAlchemy: Version 2.0.30 or newer. BetterCRUD uses SQLAlchemy for database operations.</li> <li>Pydantic: Version 2.7.3 or newer. BetterCRUD leverages Pydantic models for data validation and serialization.</li> </ul>"},{"location":"installing/#installing","title":"Installing","text":"<p>To install, just run:</p> <pre><code>pip install better-crud\n</code></pre> <p>Or, if using poetry:</p> <pre><code>poetry add better-crud\n</code></pre>"},{"location":"quick-start/","title":"Quick-Start","text":"<p>If you use SQLModel, please go directly to the SQLModel chapter</p>"},{"location":"quick-start/#minimal-example","title":"Minimal Example","text":"<p>Warning</p> <p>Prerequisites,Prepare our db, Only asynchronous mode is supported,aiomysql or aiosqlite</p> db.py<pre><code>from sqlalchemy.orm import DeclarativeBase, declared_attr\nfrom typing import AsyncGenerator\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.pool import NullPool\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nDATABASE_URL = \"sqlite+aiosqlite:///crud.db\"\n\nclass MappedBase(DeclarativeBase):\n    @declared_attr.directive\n    def __tablename__(cls) -&gt; str:\n        return cls.__name__.lower()\n\n\nclass Base(MappedBase):\n    __abstract__ = True\n\n\nengine = create_async_engine(\n    DATABASE_URL,\n    echo=False,\n    poolclass=NullPool\n)\n\nSessionLocal = sessionmaker(\n    autocommit=False,\n    autoflush=False,\n    bind=engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\n\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with SessionLocal() as session:\n        yield session\n\n\nasync def init_db():\n    async with engine.begin() as conn:\n        await conn.run_sync(MappedBase.metadata.create_all)\n</code></pre> <p>First Define Your Model And Schema</p> model.py<pre><code>from sqlalchemy import String, Integer, ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom .db import Base\n\n\nclass Pet(Base):\n    __tablename__ = \"pet\"\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n    name: Mapped[str] = mapped_column(String(100))\n    description: Mapped[str] = mapped_column(String(100))\n</code></pre> schema.py<pre><code>from typing import Optional, List\nfrom pydantic import BaseModel\n\n\nclass PetBase(BaseModel):\n    name: Optional[str] = None\n    description: Optional[str] = None\n\n\nclass PetPublic(PetBase):\n    id: int\n\n\nclass PetCreate(PetBase):\n    pass\n\n\nclass PetUpdate(PetBase):\n    pass\n</code></pre> <p>Next we need to create a service:</p> service.py<pre><code>from better_crud.service.sqlalchemy import SqlalchemyCrudService\nfrom .model import Pet\n\n\nclass PetService(SqlalchemyCrudService[Pet]):\n    def __init__(self):\n        super().__init__(Pet)\n</code></pre> <p>Next we need to define the controller and decorate it with the crud decorator Sure the controller is just a normal class,The crud decorator gives it super powers</p> controller.py<pre><code>from fastapi import APIRouter, Depends\nfrom better_crud import crud\nfrom .schema import PetCreate, PetUpdate, PetPublic\nfrom .service import PetService\n\npet_router = APIRouter()\n\n\n@crud(\n    pet_router,\n    dto={\n        \"create\": PetCreate,\n        \"update\": PetUpdate\n    },\n    serialize={\n        \"base\": PetPublic,\n    }\n)\nclass PetController():\n    service: PetService = Depends(PetService)\n</code></pre> <p>Next we can register router to the fastapi routing system</p> main.py<pre><code>from better_crud import BetterCrudGlobalConfig\nfrom fastapi import FastAPI\nfrom contextlib import asynccontextmanager\nfrom .db import get_session, init_db\n\nBetterCrudGlobalConfig.init(\n    backend_config={\n        \"sqlalchemy\": {\n            \"db_session\": get_session\n        }\n    }\n)\n\n\n@asynccontextmanager\nasync def lifespan(_: FastAPI):\n    await init_db()\n    # Shutdown\n    yield\n\napp = FastAPI(lifespan=lifespan)\n\n\ndef register_router():\n    from app.controller import pet_router\n    app.include_router(pet_router, prefix=\"/pet\")\n\n\nregister_router()\n</code></pre> <p>And it's all done, just go to /docs and the crud endpoints are created.</p>"},{"location":"sqlmodel/","title":"Using BetterCRUD with SQLModel","text":"<p>Since SQLModel combines the functionality of sqlalchemy and pydantic, all you need to do is replace the model with SQLModel</p> <p>Warning</p> <p>Prerequisites,Prepare our db, Only asynchronous mode is supported,aiomysql or aiosqlite</p> db.py<pre><code>from typing import AsyncGenerator\nfrom sqlmodel import SQLModel\nfrom sqlmodel.ext.asyncio.session import AsyncSession\nfrom sqlalchemy.pool import NullPool\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nDATABASE_URL = \"sqlite+aiosqlite:///crud.db\"\n\nengine = create_async_engine(\n    DATABASE_URL,\n    echo=False,\n    poolclass=NullPool\n)\n\nSessionLocal = sessionmaker(\n    autocommit=False,\n    autoflush=False,\n    bind=engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\n\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with SessionLocal() as session:\n        yield session\n\n\nasync def init_db():\n    async with engine.begin() as conn:\n        await conn.run_sync(SQLModel.metadata.create_all)\n</code></pre> <p>First Define your SQLModel model</p> model.py<pre><code>from typing import Optional, List\nfrom sqlmodel import Field, SQLModel, Relationship\n\n\nclass PetBase(SQLModel):\n    name: Optional[str] = None\n    description: Optional[str] = Field(default=None)\n\n\nclass Pet(PetBase, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n\n\nclass PetPublic(PetBase):\n    id: Optional[int]\n\n\nclass PetCreate(PetBase):\n    pass\n\n\nclass PetUpdate(PetBase):\n    pass\n</code></pre> <p>Next we need to create a service:</p> service.py<pre><code>from better_crud.service.sqlalchemy import SqlalchemyCrudService\nfrom .model import Pet\n\n\nclass PetService(SqlalchemyCrudService[Pet]):\n    def __init__(self):\n        super().__init__(Pet)\n</code></pre> <p>Next we need to define the controller and decorate it with the crud decorator Sure the controller is just a normal class,The crud decorator gives it super powers</p> controller.py<pre><code>from fastapi import APIRouter, Depends\nfrom better_crud import crud\nfrom .model import PetCreate, PetUpdate, PetPublic\nfrom .service import PetService\n\npet_router = APIRouter()\n\n\n@crud(\n    pet_router,\n    dto={\n        \"create\": PetCreate,\n        \"update\": PetUpdate\n    },\n    serialize={\n        \"base\": PetPublic,\n    }\n)\nclass PetController():\n    service: PetService = Depends(PetService)\n</code></pre> <p>Next we can register router to the fastapi routing system</p> main.py<pre><code>from better_crud import BetterCrudGlobalConfig\nfrom fastapi import FastAPI\nfrom contextlib import asynccontextmanager\nfrom .db import get_session, init_db\n\nBetterCrudGlobalConfig.init(\n    backend_config={\n        \"sqlalchemy\": {\n            \"db_session\": get_session\n        }\n    }\n)\n\n\n@asynccontextmanager\nasync def lifespan(_: FastAPI):\n    await init_db()\n    # Shutdown\n    yield\n\napp = FastAPI(lifespan=lifespan)\n\n\ndef register_router():\n    from app.controller import pet_router\n    app.include_router(pet_router, prefix=\"/pet\")\n\n\nregister_router()\n</code></pre> <p>And it's all done, just go to /docs and the crud endpoints are created.</p>"},{"location":"advanced/acl_guard/","title":"ACL Guard","text":"<p>Sometimes we want to implement an ACL Guard function acl.py<pre><code>from fastapi import Depends, Request\nfrom better_crud import get_feature\n\nasync def acl(request: Request):\n    feature = get_feature(request)\n    action = get_action(request)\n    #Your ACL logic implementation\n\nACLDepend = Depends(acl)\n</code></pre></p> main.py<pre><code>from .acl import ACLDepend\n\nBetterCrudGlobalConfig.init(\n    routes={\n        \"dependencies\":[ACLDepend],\n    },\n)\n</code></pre> some_router.py<pre><code>@crud(\n    feature=\"test\"\n)\nclass TestController():\n    pass\n</code></pre> <ul> <li>get_action will return the action_map value set in BetterCrudGlobalConfig for the corresponding route</li> <li>get_feature will return the feature parameter value of the corresponding route in the crud decorator</li> </ul>"},{"location":"advanced/function_based_view/","title":"Function based view","text":"<p>Sometimes you don't want to use class-based views. Of course, BetterCRUD provides another way based on the traditional function view mode.</p> <p>company_router.py<pre><code>from fastapi import APIRouter, Depends, Request\nfrom better_crud import crud_generator\nfrom app.models.company import CompanyPublic, CompanyCreate, CompanyUpdate, Company\nrouter = APIRouter()\ncrud_generator(\n    router,\n    Company,\n    dto={\"create\": CompanyCreate, \"update\": CompanyUpdate},\n    routes={},\n    serialize={\"base\": CompanyPublic}\n)\n</code></pre> crud_generator function and crud decorator parameters are basically the same</p> <p>In this mode, there is no need to define a service</p> <p>If you just want to quickly generate your CRUD routing port without too much business logic in it, this mode will suit you</p> <p>In addition, crud_generator also provides hooks calls</p> <pre><code>crud_generator(\n    router,\n    Company,\n    dto={\"create\": CompanyCreate, \"update\": CompanyUpdate},\n    routes={},\n    serialize={\"base\": CompanyPublic},\n    on_before_create=on_before_create,\n    on_after_create=on_after_create,\n    on_before_update=on_before_update,\n    on_after_update=on_after_update,\n    on_before_delete=on_before_delete,\n    on_after_delete=on_after_delete\n)\n</code></pre> <p>Warning</p> <p>In this mode, if you need to define a route rewrite, put the definition before calling crud_generator</p> <pre><code>from fastapi import APIRouter, Depends, Request\nfrom better_crud import crud_generator\nfrom app.models.company import CompanyPublic, CompanyCreate, CompanyUpdate, Company\nfrom app.services.company import CompanyService\nrouter = APIRouter()\n\n\n@router.get(\"\")\nasync def override_get_many():\n    return []\n\n\ncrud_generator(\n    router,\n    Company,\n    dto={\"create\": CompanyCreate, \"update\": CompanyUpdate},\n    routes={},\n    serialize={\"base\": CompanyPublic}\n)\n</code></pre>"},{"location":"advanced/hooks/","title":"CRUD Hooks","text":""},{"location":"advanced/hooks/#hooks-on-your-crud-action","title":"Hooks on your crud action","text":"Name Description on_before_create Called before creation on_after_create Called after creation on_before_update Called before update on_after_update Called after update on_before_delete Called before deletion on_after_delete Called after deletion <p>The corresponding function signature is as follows</p> <pre><code>from pydantic import BaseModel\nfrom fastapi import BackgroundTasks\n\n\nCreateSchemaType = TypeVar(\"CreateSchemaType\", bound=BaseModel)\nUpdateSchemaType = TypeVar(\"UpdateSchemaType\", bound=BaseModel)\n\nasync def on_before_create(\n    self,\n    model: CreateSchemaType,\n    background_tasks: Optional[BackgroundTasks] = None\n) -&gt; Union[Dict[str, Any], None]:\n    pass\n\nasync def on_after_create(\n    self,\n    entity: ModelType,\n    background_tasks: BackgroundTasks\n) -&gt; None:\n    pass\n\nasync def on_before_update(\n    self,\n    entity: ModelType,\n    model: UpdateSchemaType,\n    background_tasks: BackgroundTasks\n) -&gt; Union[Dict[str, Any], None]:\n    pass\n\nasync def on_after_update(\n    self,\n    entity: ModelType,\n    background_tasks: BackgroundTasks\n) -&gt; None:\n    pass\n\nasync def on_before_delete(\n    self,\n    entities: List[ModelType],\n    background_tasks: BackgroundTasks\n) -&gt; None:\n    pass\n\nasync def on_after_delete(\n    self,\n    entities: List[ModelType],\n    background_tasks: BackgroundTasks\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"advanced/hooks/#example1","title":"Example1","text":"<p>Process the password passed in by the user</p> user_service.py<pre><code>from fastapi import Depends\nfrom better_crud.service.sqlalchemy import SqlalchemyCrudService\nfrom app.models.user import User, UserCreate, UserUpdate\nfrom app.core.security import get_hashed_password\n\nclass UserService(SqlalchemyCrudService[User]):\n    def __init__(self):\n        super().__init__(User)\n\n    async def on_before_create(self, user_create: UserCreate, **kwargs):\n        hashed_password = get_hashed_password(user_create.password)\n        user_create.password = None\n        return {\n            \"hashed_password\": hashed_password\n        }\n\n    async def on_before_update(self, entity: User, user_update: UserUpdate, **kwargs):\n        if user_update.password is not None:\n            hashed_password = get_hashed_password(user_update.password)\n            user_update.password = None\n            return {\n                \"hashed_password\": hashed_password\n            }\n</code></pre>"},{"location":"advanced/hooks/#example2","title":"Example2","text":"<p>Check if it exists before creating it</p> user_service.py<pre><code>from fastapi import Depends\nfrom better_crud.service.sqlalchemy import SqlalchemyCrudService\nfrom app.models.user import User, UserCreate, UserUpdate\nfrom app.core.security import get_hashed_password\n\nclass UserService(SqlalchemyCrudService[User]):\n    def __init__(self):\n        super().__init__(User)\n\n    async def on_before_create(self, user_create: UserCreate, **kwargs):\n        exist_by_user_name = await self.get_one([User.user_name == user_create.user_name])\n        if exist_by_user_name:\n            raise BadRequestError(msg=f\"The user_name {user_create.user_name} already exists\")\n</code></pre>"},{"location":"advanced/joins/","title":"Joining Models","text":"<p>In real projects, models are related and may reference each other. This is very common in sqlalchemy/SQLModel. Of course, BetterCRUD supports this behavior with some simple configuration.</p> <p>If there is a user model, similar to the following structure</p> <p><pre><code>class UserBase(SQLModel):\n    email: Optional[str] = Field(default=None)\n    is_active: Optional[bool] = Field(default=True)\n    is_superuser: Optional[bool] = Field(default=False)\n\nclass User(UserBase, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    user_name: str\n    hashed_password: str\n    profile_id: Optional[int] = Field(\n        default=None, foreign_key=\"user_profile.id\")\n    company_id: Optional[int] = Field(default=None, foreign_key=\"company.id\")\n    profile: UserProfile = Relationship(\n        sa_relationship_kwargs={\"uselist\": False, \"lazy\": \"noload\"})\n    tasks: List[UserTask] = Relationship(\n        sa_relationship_kwargs={\"uselist\": True,\n                                \"order_by\": \"UserTask.id.asc()\",\n                                \"cascade\": \"all, delete-orphan\",\n                                \"lazy\": \"noload\"})\n    staff: Staff = Relationship(\n        sa_relationship_kwargs={\"uselist\": False, \"lazy\": \"noload\"})\n    company: Company = Relationship(\n        sa_relationship_kwargs={\"uselist\": False, \"lazy\": \"noload\"})\n    roles: List[\"Role\"] = Relationship(back_populates=\"users\", sa_relationship_kwargs={\n                                       \"lazy\": \"noload\"}, link_model=UserRoleLink)\n    projects: List[\"Project\"] = Relationship(back_populates=\"users\", sa_relationship_kwargs={\n        \"lazy\": \"noload\"}, link_model=UserProjectLink)\n    deleted_at: Optional[datetime] = Field(\n        default=None, sa_column=Column(DateTime(timezone=True), nullable=True)\n    )\n    created_at: Optional[datetime] = Field(\n        default=None, sa_column=Column(DateTime(timezone=True), nullable=True)\n    )\n</code></pre> These relationships are not loaded by default,They are all configured with noload</p> <p>You can control which relationships can be loaded and which relationships can be associated in the query joins in the crud decorator</p> <pre><code>@crud(\n    query={\n        \"joins\": {\n            \"profile\": {\n                \"select\": True,\n                \"join\": False\n            },\n            \"tasks\": {\n                \"select\": True,\n                \"join\": False\n            },\n            \"company\": {\n                \"select\": True,\n                \"join\": False\n            },\n            \"roles\": {\n                \"select\": True,\n                \"join\": False\n            },\n            \"staff\": {\n                \"select\": True,\n            },\n            \"projects\": {\n                \"select\": True,\n            },\n            \"projects.company\": {\n                \"select\": True,\n                \"join\": False\n            }\n        }\n    }\n)\nclass UserController():\n    service: UserService = Depends(UserService)\n</code></pre> <p>Let me introduce the configuration items of join below</p> <pre><code>class JoinOptionsDict(TypedDict, total=False):\n    select: Optional[bool] = True\n    join: Optional[bool] = True\n    select_only_detail: Optional[bool] = False\n    additional_filter_fn: Optional[Callable[[Any], List[Any]]] = None\n    alias: Optional[Any] = None\n</code></pre>"},{"location":"advanced/joins/#1-select-determines-whether-to-load-relations-in-a-query","title":"1. select (Determines whether to load relations in a query)","text":""},{"location":"advanced/joins/#2-join-determine-which-relationships-will-be-joined","title":"2. join (Determine which relationships will be joined)","text":""},{"location":"advanced/joins/#3-select_only_detail-is-it-only-loaded-in-the-get-one-route","title":"3. select_only_detail (Is it only loaded in the Get One route?)","text":""},{"location":"advanced/joins/#4-addadditional_filter_fnadd-some-additional-query-conditions-to-your-own-association-conditions","title":"4. addadditional_filter_fn(Add some additional query conditions to your own association conditions)","text":"<pre><code>@crud(\n    query={\n        \"joins\": {\n            \"roles\": {\n                \"select\": True,\n                \"join\": False,\n                \"additional_filter_fn\":lambda _: Role.id == 2\n            }\n        }\n    }\n)\nclass UserController():\n    service: UserService = Depends(UserService)\n</code></pre>"},{"location":"advanced/joins/#4-alias","title":"4. alias","text":"<p>Sometimes your model has multiple properties that reference the same relationship At this time you need to set it aliased</p> <pre><code>from sqlalchemy.orm import aliased\n\nModifierUser = aliased(User)\n\nclass Post(PostBase, table=True):\n    __tablename__ = \"post\"\n    id: Optional[int] = Field(default=None, primary_key=True)\n    creater_user_id: Optional[int] = Field(\n        default=None, foreign_key=\"user.id\"\n    )\n    modifier_user_id: Optional[int] = Field(\n        default=None, foreign_key=\"user.id\"\n    )\n\n    creater_user: User = Relationship(\n        sa_relationship_kwargs={\"uselist\": False, \"lazy\": \"noload\", \"foreign_keys\": \"[Post.creater_user_id]\"})\n\n    modifier_user: User = Relationship(\n        sa_relationship_kwargs={\"uselist\": False, \"lazy\": \"noload\", \"foreign_keys\": \"[Post.modifier_user_id]\"})\n\n@crud(\n    router,\n    dto={\"create\": PostCreate, \"update\": PostUpdate},\n    serialize={\"base\": PostPublic},\n    query={\n        \"joins\": {\n            \"creater_user\": {\n                \"select\": True,\n                \"join\": True\n            },\n            \"modifier_user\": {\n                \"select\": True,\n                \"join\": True,\n                \"alias\": ModifierUser\n            }\n        },\n    }\n)\nclass PostController():\n    service: PostService = Depends(PostService)\n</code></pre>"},{"location":"advanced/relationship/","title":"Relationship Storage","text":"<p>BetterCRUD not only supports the query of relations, but also supports the storage of relational data, It allows you to write less boilerplate code.</p> <p>For example, we have a model class</p> <pre><code>class UserBase(SQLModel):\n    email: Optional[str] = Field(default=None)\n    is_active: Optional[bool] = Field(default=True)\n    is_superuser: Optional[bool] = Field(default=False)\n\nclass User(UserBase, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    user_name: str\n    hashed_password: str\n    profile_id: Optional[int] = Field(\n        default=None, foreign_key=\"user_profile.id\")\n    company_id: Optional[int] = Field(default=None, foreign_key=\"company.id\")\n    profile: UserProfile = Relationship(\n        sa_relationship_kwargs={\"uselist\": False, \"lazy\": \"noload\"})\n    tasks: List[UserTask] = Relationship(\n        sa_relationship_kwargs={\"uselist\": True,\n                                \"order_by\": \"UserTask.id.asc()\",\n                                \"cascade\": \"all, delete-orphan\",\n                                \"lazy\": \"noload\"})\n    staff: Staff = Relationship(\n        sa_relationship_kwargs={\"uselist\": False, \"lazy\": \"noload\"})\n    company: Company = Relationship(\n        sa_relationship_kwargs={\"uselist\": False, \"lazy\": \"noload\"})\n    roles: List[\"Role\"] = Relationship(back_populates=\"users\", sa_relationship_kwargs={\n                                       \"lazy\": \"noload\"}, link_model=UserRoleLink)\n    projects: List[\"Project\"] = Relationship(back_populates=\"users\", sa_relationship_kwargs={\n        \"lazy\": \"noload\"}, link_model=UserProjectLink)\n    deleted_at: Optional[datetime] = Field(\n        default=None, sa_column=Column(DateTime(timezone=True), nullable=True)\n    )\n    created_at: Optional[datetime] = Field(\n        default=None, sa_column=Column(DateTime(timezone=True), nullable=True)\n    )\n</code></pre> <p>We hope to automatically store the corresponding relationship data in the post/put request body We only need to define the corresponding dto class to contain the corresponding relational data model definition</p> <pre><code>class UserCreate(UserBase):\n    profile: Optional[UserProfileCreate] = None\n    roles: Optional[List[int]] = None\n    tasks: Optional[List[UserTaskCreate]] = None\n    staff: Optional[StaffCreate] = None\n    projects: Optional[List[int]] = None\n</code></pre> <p>Your request body will include the corresponding relationship definition</p> <p></p> <p>The relevant data will be stored in your database along with the request.</p> <p>Magical and useful features \ud83e\udd13</p> <p>The following relationships are supported</p> <ul> <li>MANYTOMANY</li> <li>ONETOMANY</li> <li>ONETOONE</li> <li>MANYTOONE</li> </ul>"},{"location":"usage/crud/","title":"CRUD Decorator","text":"<p>An ordinary class is decorated with a CRUD decorator to give it CRUD capabilities, just like Spider-Man, who was bitten by a spider and gained super powers.</p> <p>I think this is a good use case for python decorators</p> <pre><code>from fastapi import APIRouter, Depends\nfrom better_crud import crud\nfrom .schema import PetCreate, PetUpdate, PetPublic\nfrom .service import PetService\npet_router = APIRouter()\n@crud(\n    pet_router,\n    dto={\n        \"create\": PetCreate,\n        \"update\": PetUpdate\n    },\n    serialize={\n        \"base\": PetPublic,\n    }\n)\nclass PetController():\n    service: PetService = Depends(PetService)\n</code></pre> <p>Warning</p> <p>crud is a python class decorator,cannot be used in decorated functions</p> <p>Let me introduce the parameters of the decorator below</p> <pre><code>def crud(\n    router: APIRouter,\n    *,\n    serialize: SerializeModelDict,\n    params: Optional[Dict[str, PathParamDict]] = None,\n    routes: Optional[RoutesModelDict] = {},\n    dto: DtoModelDict = {},\n    auth: Optional[AuthModelDict] = {},\n    query: Optional[QueryOptionsDict] = {},\n    summary_vars: Optional[Dict] = {},\n    feature: Optional[str] = \"\",\n) -&gt; Callable[[Type[T]], Type[T]]:\n</code></pre> <ul> <li>serialize</li> <li>params</li> <li>routes</li> <li>dto</li> <li>auth</li> <li>query</li> <li>summary_vars</li> <li>feature</li> </ul>"},{"location":"usage/crud/#serialize","title":"serialize","text":"<p>Response serialization DTO classes. Compatible with fastapi serialization</p> <pre><code>class SerializeModelDict(TypedDict, total=False):\n    base: Any\n    get_many: Optional[Any] = None\n    get_one: Optional[Any] = None\n    create_one: Optional[Any] = None\n    create_many: Optional[Any] = None\n    update_one: Optional[Any] = None\n    delete_many: Optional[Any] = None\n</code></pre> <pre><code>from pydantic import BaseModel\n\nclass GetManyModel(BaseModel):\n    id:int\n    name: Optional[str] = None\n    description: Optional[str] = None\n</code></pre> <p>If you use SQLModel</p> <pre><code>from sqlmodel import Field, SQLModel, Relationship\n\nclass GetManyModel(SQLModel):\n    id:int\n    name: Optional[str] = None\n    description: Optional[str] = Field(default=None)\n</code></pre> <pre><code>@crud(\n    router,\n    serialize={\n        \"get_many\":GetManyModel\n        **others\n    }\n)\n</code></pre> <p>Of course, if all your response model structures are the same, you only need to define base,this means that all responses are serialized in the same structure.</p> <pre><code>@crud(\n    router,\n    serialize={\n        \"base\":GetManyModel\n    }\n)\n</code></pre>"},{"location":"usage/crud/#params","title":"params","text":"<p>If you have a router path with that looks kinda similar to this /:user_id/user_task you need to add this param option:</p> <pre><code>@crud(\n    user_task_router,\n    params={\n        \"user_id\": {\n            \"field\": \"user_id\",\n            \"type\": \"int\"\n        }\n    }\n)\napi_router.include_router(user_task_router, prefix=\"/{user_id}/user_task\")\n</code></pre>"},{"location":"usage/crud/#routes","title":"routes","text":"<p>The function is the same as routes in Global Config</p>"},{"location":"usage/crud/#dto","title":"dto","text":"<p>Request body model classes. see fastapi Request Body</p> <p>Used in create/update routes respectively</p> <pre><code>@crud(\n    dto={\n        \"create\": PetCreate, #create one/create many\n        \"update\": PetUpdate #update one/update many\n    },\n)\n</code></pre>"},{"location":"usage/crud/#auth","title":"auth","text":"<p>In order to perform data filtering for authenticated requests,</p> <p><pre><code>@crud(\n    auth={\n        \"persist\": lambda x: {\"user_id\": 1},\n        \"filter\": lambda x: {\"user_id\": 1},\n    }\n)\n</code></pre> persist - a function that can return an object that will be added to the DTO on create, update actions. Useful in case if you need to prevent changing some sensitive entity properties even if it's allowed in DTO validation.</p> <p>filter - a function that should return search condition and will be added to the query search params and path params as a $and condition:</p>"},{"location":"usage/crud/#query","title":"query","text":"<p>Some query related configuration</p> <pre><code>class QueryOptionsDict(TypedDict, total=False):\n    joins: Optional[Dict[str, JoinOptionsDict]] = None\n    soft_delete: Optional[bool] = None\n    allow_include_deleted: Optional[bool] = False\n    filter: Optional[Dict] = None\n    sort: Optional[List[QuerySortDict]] = None\n</code></pre> Name Type Description joins Dict[str, JoinOptionsDict] Set the depends of the route soft_delete bool Whether to allow soft deletion allow_include_deleted bool Set whether to allow the inclusion of deleted data filter Dict Some filter conditions sort List[QuerySortDict] Set query sorting method"},{"location":"usage/crud/#summary_vars","title":"summary_vars","text":"<p>You can set some variables used in summary</p> <p>For example, if you set a summary of some routes globally</p> <p><pre><code>BetterCrudGlobalConfig.init(\n    backend_config={\n        \"sqlalchemy\": {\n            \"db_session\": get_session\n        }\n    },\n    page_schema=Page,\n    routes={\n        \"get_many\": {\n            \"summary\": \"Get Many for {name}\"\n        }\n    }\n)\n</code></pre> You used the variable name in the summary of the get_many route</p> <p><pre><code>@crud(\n    summary_vars={\n        \"name\": \"cat\"\n    }\n)\n</code></pre> Now the summary inside the get_many route will be 'Get Many for cat'</p> <p></p>"},{"location":"usage/crud/#feature","title":"feature","text":"<p>Used to set the value returned by the corresponding route get_feature function in ACL Guard</p>"},{"location":"usage/global_config/","title":"Global Config","text":"<p>Some configurations are for the route level, of course, you can also configure it globally, otherwise each route needs to be reconfigured once. The design is designed to be configured globally, and can be overridden at the routing level</p> <pre><code>from better_crud import BetterCrudGlobalConfig\n\nBetterCrudGlobalConfig.init(**config)\n\n@classmethod\ndef init(\n    cls,\n    *,\n    backend_config: Optional[BackendConfigDict] = None,\n    query: Optional[GlobalQueryOptionsDict] = {},\n    routes: Optional[RoutesModelDict] = {},\n    delim_config: Optional[QueryDelimOptionsDict] = {},\n    soft_deleted_field_key: Optional[str] = None,\n    action_map: Optional[Dict[str, str]] = None,\n    page_schema: Optional[AbstractPage] = Page,\n    response_schema: Optional[AbstractResponseModel] = None\n) -&gt; None:\n</code></pre> <p>Warning</p> <p>So in order to apply the global configuration you need to execute init before importing the routing class. This is because python decorators are executed when we declare the class, not when we create a new class instance. So in your main.py:</p> main.py<pre><code>BetterCrudGlobalConfig.init(\n    backend_config={\n        \"sqlalchemy\": {\n            \"db_session\": get_session\n        }\n    }\n)\napp = FastAPI(lifespan=lifespan)\n\n\ndef register_router():\n    from app.controller import pet_router\n    app.include_router(pet_router, prefix=\"/pet\")\n\n\nregister_router()\n</code></pre> <ul> <li>backend_config</li> <li>1. Define Your db_session</li> <li>2. Custom Your Backend</li> <li>query</li> <li>routes</li> <li>1. Set global dependencies</li> <li>2. Only Get Many,Get One route</li> <li>3. Exclude Create Many route</li> <li>delim_config</li> <li>soft_deleted_field_key</li> <li>action_map</li> <li>page_schema</li> <li>response_schema</li> </ul>"},{"location":"usage/global_config/#backend_config","title":"backend_config","text":"<pre><code>DBSessionFactory = Callable[..., Union[AsyncGenerator[Any, None], Any]]\n\nclass SqlalchemyBackendDict(TypedDict):\n    db_session: DBSessionFactory\n\nBackendType = Literal[\n    \"sqlalchemy\",\n    \"custom\"\n]\n\nclass BackendConfigDict(TypedDict):\n    backend: BackendType\n    sqlalchemy: SqlalchemyBackendDict\n</code></pre>"},{"location":"usage/global_config/#1-define-your-db_session","title":"1. Define Your db_session","text":"<p>db_session is an asynchronous generator function that returns type AsyncSession</p> <pre><code>from sqlalchemy.ext.asyncio import AsyncSession\n\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with SessionLocal() as session:\n        yield session\n\nBetterCrudGlobalConfig.init(\n    backend_config={\n        \"sqlalchemy\": {\n            \"db_session\": get_session\n        }\n    }\n)\n</code></pre> <p>If you use fastapi_sqlalchemy</p> <pre><code>from fastapi_sqlalchemy import db\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    yield db.session\n</code></pre>"},{"location":"usage/global_config/#2-custom-your-backend","title":"2. Custom Your Backend","text":"<p>Currently, only the backend of sqlalchemy is implemented Of course, you can implement your own backend by setting backend to custom, For example, here's how</p> <p><pre><code>from better_crud import BetterCrudGlobalConfig\n\nBetterCrudGlobalConfig.init(\n    backend_config={\n        \"backend\":\"custom\"\n    }\n)\n</code></pre> Your backend class inherits AbstractCrudService and implements its abstract methods</p> <p>The business service inherits from it service.py<pre><code>from better_crud import register_backend\nfrom better_crud.service.abstract import AbstractCrudService\nfrom .model import Pet\n\n@register_backend(\"custom\")\nclass YourCustomCrudService(\n    Generic[ModelType],\n    AbstractCrudService[ModelType]\n):\n    pass\n\nclass PetService(YourCustomCrudService[Pet]):\n    def __init__(self):\n        super().__init__(Pet)\n</code></pre></p>"},{"location":"usage/global_config/#query","title":"query","text":"<p>Configuration of some global query parameters <pre><code>class GlobalQueryOptionsDict(TypedDict, total=False):\n    soft_delete: Optional[bool] = False\n    sort: Optional[List[QuerySortDict]] = None\n    allow_include_deleted: Optional[bool] = False\n\nclass QuerySortDict(TypedDict):\n    field: str\n    sort: Literal[\"ASC\", \"DESC\"]\n</code></pre></p> <p>GlobalQueryOptionsDict</p> Name Type Description soft_delete bool Decide whether soft delete is enabled sort List[QuerySortDict] Sort configuration and support for multiple fields allow_include_deleted bool Query whether data that has been soft-deleted is allowed <p>QuerySortDict</p> Name Type Description field str Sort fields sort Literal[\"ASC\", \"DESC\"] ASC ascending and DESC descending"},{"location":"usage/global_config/#routes","title":"routes","text":"<p>Used to exclude or include only some routes, and to set route dependencies</p> Name Type Description dependencies Sequence[params.Depends] Set the depends of the route only List[RoutesEnumType] Only contain routes exclude List[RoutesEnumType] Routes that need to be excluded get_many RouteOptionsDict Route config for get_many get_one RouteOptionsDict Route config for get_one create_one RouteOptionsDict Route config for create_one create_many RouteOptionsDict Route config for create_many update_one RouteOptionsDict Route config for update_one update_many RouteOptionsDict Route config for update_many delete_many RouteOptionsDict Route config for delete_many <pre><code>RoutesEnumType = Literal[\n    \"get_many\",\n    \"get_one\",\n    \"create_one\",\n    \"create_many\",\n    \"update_one\",\n    \"update_many\",\n    \"delete_many\"\n]\n\nclass RouteOptionsDict(TypedDict, total=False):\n    dependencies: Optional[Sequence[params.Depends]] = None\n    summary: Optional[str] = None\n</code></pre> <p>RouteOptionsDict</p> Name Type Description dependencies Sequence[params.Depends] Set the depends of the route summary str Set the summary of the swagger"},{"location":"usage/global_config/#1-set-global-dependencies","title":"1. Set global dependencies","text":"<pre><code>from fastapi.security import HTTPBearer\nfrom fastapi import Depends\nJWTDepend = Depends(HTTPBearer())\n\nBetterCrudGlobalConfig.init(\n    routes={\n        \"dependencies\":[JWTDepend],\n    }\n)\n</code></pre>"},{"location":"usage/global_config/#2-only-get-manyget-one-route","title":"2. Only Get Many,Get One route","text":"<pre><code>from fastapi.security import HTTPBearer\nfrom fastapi import Depends\nJWTDepend = Depends(HTTPBearer())\n\nBetterCrudGlobalConfig.init(\n    routes={\n        \"only\":[\"get_many\",\"get_one\"]\n    }\n)\n</code></pre>"},{"location":"usage/global_config/#3-exclude-create-many-route","title":"3. Exclude Create Many route","text":"<pre><code>from fastapi.security import HTTPBearer\nfrom fastapi import Depends\nJWTDepend = Depends(HTTPBearer())\n\nBetterCrudGlobalConfig.init(\n    routes={\n        \"exclude\":[\"create_many\"]\n    }\n)\n</code></pre>"},{"location":"usage/global_config/#delim_config","title":"delim_config","text":"<p>Splitter config <pre><code>class QueryDelimOptionsDict(TypedDict, total=False):\n    delim: Optional[str] = \"||\"\n    delim_str: Optional[str] = \",\"\n</code></pre> delim is used to split multiple query criteria</p> <ul> <li>?filter=field||condition||value</li> <li>?filter=user_name||$eq||alice</li> <li>?filter=age||$gt||20</li> </ul> <p>delim_str is used to split order field and sort by</p> <ul> <li>?order=age,ASC</li> <li>?order=id,DESC</li> </ul>"},{"location":"usage/global_config/#soft_deleted_field_key","title":"soft_deleted_field_key","text":"<p>To set up a soft-delete field, you can use e.g. deleted_at, expiry_at,Represents a timestamp,When the data was deleted</p>"},{"location":"usage/global_config/#action_map","title":"action_map","text":"<p>Default ACL action map</p> Route Action get_many read read_one read create_one create create_many create update_one update update_many update delete_many delete <p>Your can custom your action map</p> <pre><code>BetterCrudGlobalConfig.init(\n    action_map={\n        RoutesEnum.get_many: \"read-all\",\n        RoutesEnum.get_one: \"read-one\",\n        RoutesEnum.create_one:\"create-one\"\n        RoutesEnum.create_many: \"create-many\",\n        RoutesEnum.update_one: \"update-one\",\n        RoutesEnum.update_many: \"update-many\",\n        RoutesEnum.delete_many: \"delete-many\"\n    }\n)\n</code></pre> <p>Used to set the value returned by the corresponding route get_action function in ACL Guard</p>"},{"location":"usage/global_config/#page_schema","title":"page_schema","text":"<p>BetterCRUD uses fastapi-pagination  as the built-in paging method, so you can customize your paging model more flexibly</p> <p>By default, page and size are used as paging query parameters.</p> <p>?page=1&amp;size=10</p> <p>Of course you can change this behavior,the following example uses page1 and size1 as URL query parameters</p> pagination.py<pre><code>from __future__ import annotations\n\nimport math\nfrom typing import Generic, Sequence, TypeVar, Optional, Any\nfrom fastapi import Query\nfrom fastapi_pagination.bases import AbstractPage, AbstractParams, RawParams\nfrom pydantic import BaseModel\n\n\nT = TypeVar('T')\n\n\nclass Params(BaseModel, AbstractParams):\n    page1: Optional[int] = Query(\n        default=None, gte=0, description='Page number')\n    size1: Optional[int] = Query(\n        default=None,\n        gte=0,\n        le=100,\n        description='Page size'\n    )\n\n    def to_raw_params(self) -&gt; RawParams:\n        return RawParams(\n            limit=self.size1,\n            offset=self.size1 * (self.page1 - 1),\n        )\n\n\nclass Page(AbstractPage[T], Generic[T]):\n    records: Sequence[T]\n    total: int\n    page: int\n    size: int\n    pages: int\n    __params_type__ = Params\n\n    @classmethod\n    def create(\n        cls,\n        items: Sequence[T],\n        params: Params,\n        *,\n        total: Optional[int] = None,\n        **kwargs: Any,\n    ) -&gt; Page[T]:\n        size = params.size1 if params.size1 is not None else (total or None)\n        page = params.page1 if params.page1 is not None else 1\n        if size in {0, None}:\n            pages = 0\n        elif total is not None:\n            pages = math.ceil(total / size)\n        else:\n            pages = None\n        return cls(records=items, total=total, page=page, size=size, pages=pages)\n</code></pre> main.py<pre><code>BetterCrudGlobalConfig.init(\n    page_schema=Page\n)\n</code></pre>"},{"location":"usage/global_config/#response_schema","title":"response_schema","text":"<p>Configure your response schema</p> <pre><code>from typing import Any, TypeVar, Generic\nfrom better_crud import AbstractResponseModel\nT = TypeVar(\"T\")\n\nclass ResponseModel(AbstractResponseModel, Generic[T]):\n\n    code: int = 200\n    msg: str = \"Success\"\n    data: T | None = None\n\n    @classmethod\n    def create(\n        cls, content: Any\n    ):\n        return cls(\n            data=content,\n            msg=\"success\"\n        )\n\n\nBetterCrudGlobalConfig.init(\n    response_schema=ResponseModel,\n)\n</code></pre>"},{"location":"usage/query_params/","title":"Query params","text":"<p>By default, we support these param names:</p> Name Description s search conditions (like JSON Query) filter filter result by AND type of condition or filter result by OR type of condition page current page, starting from 1 size page size load determines whether certain relationships are queried join join relationship by query sort add sort by field (support multiple fields) and order to query result. <ul> <li>s</li> <li>1. Plain Object Literal</li> <li>2. Object Literal With Operator</li> <li>3. Queries with and</li> <li>4. Queries with or</li> <li>5.Combining $and and $or</li> <li>filter operator</li> <li>filter</li> <li>or</li> <li>page</li> <li>size</li> <li>load</li> <li>join</li> <li>sort</li> </ul>"},{"location":"usage/query_params/#s","title":"s","text":"<p>JSON string as search criteria</p> <p>Why use JSON string?</p> <p>Better expressiveness</p> <p>Syntax:</p> <p>?s={\"name\": \"andy\"}</p> <p>There are the following variants</p>"},{"location":"usage/query_params/#1-plain-object-literal","title":"1. Plain Object Literal","text":"<p>All equal query relations</p> <p><pre><code>{\n    name: \"John\",\n    age: 30,\n    address: \"123 Main Street\"\n}\n</code></pre> Search an entity where name equal John and age equal 30 and address equal 123 Main Street</p>"},{"location":"usage/query_params/#2-object-literal-with-operator","title":"2. Object Literal With Operator","text":"<p><pre><code>{\n    name: {\n        \"$cont\":\"andy\"\n    },\n    age:{\n        \"$eq\":30\n    },\n    address:{\n        \"$eq\":\"123 Main Street\"\n    }\n}\n</code></pre> The following SQL statement is expressed <pre><code>name like '%andy%' and age=30 and address='123 Main Street'\n</code></pre></p> <p>all filter operator as follows</p>"},{"location":"usage/query_params/#3-queries-with-and","title":"3. Queries with and","text":"<pre><code>{\n    \"$and\": [\n        {\n            \"name\": {\n                \"$cont\": \"andy\"\n            }\n        },\n        {\n            \"age\": {\n                \"$eq\": 30\n            }\n        },\n        {\n            \"address\": {\n                \"$eq\": \"123 Main Street\"\n            }\n        }\n    ]\n}\n</code></pre> <p>Of course, unlimited nesting is also supported</p> <pre><code>{\n    \"$and\": [\n        {\n            \"name\": {\n                \"$cont\": \"andy\"\n            }\n        },\n        {\n            \"$and\":[\n                {\n                    \"age\": {\n                        \"$eq\": 30\n                    }\n                },\n                {\n                    \"address\": {\n                        \"$eq\": \"123 Main Street\"\n                    }\n                }\n            ]\n        }\n    ]\n}\n</code></pre> <p>Warning</p> <p>If $and and other keys exist in a query object, the other keys will be ignored.</p>"},{"location":"usage/query_params/#4-queries-with-or","title":"4. Queries with or","text":"<pre><code>{\n    \"$or\": [\n        {\n            \"name\": {\n                \"$cont\": \"andy\"\n            }\n        },\n        {\n            \"age\": {\n                \"$eq\": 30\n            }\n        },\n        {\n            \"address\": {\n                \"$eq\": \"123 Main Street\"\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"usage/query_params/#5combining-and-and-or","title":"5.Combining $and and $or","text":"<pre><code>{\n    \"$and\":[\n        {\n            \"gender\":\"female\"\n        },\n        \"$or\": [\n            {\n                \"name\": {\n                    \"$cont\": \"andy\"\n                }\n            },\n            {\n                \"age\": {\n                    \"$eq\": 30\n                }\n            },\n            {\n                \"address\": {\n                    \"$eq\": \"123 Main Street\"\n                }\n            }\n        ]\n    ]\n}\n</code></pre>"},{"location":"usage/query_params/#filter-operator","title":"filter operator","text":"<ul> <li>$eq (=, equal)</li> <li>$ne (!=, not equal)</li> <li>$gt (&gt;, greater than)</li> <li>$gte (&gt;=, greater than or equal)</li> <li>$lt (&lt;, lower that)</li> <li>$lte (&lt;=, lower than or equal)</li> <li>$cont (LIKE %val%, contains)</li> <li>$excl (NOT LIKE %val%, not contains)</li> <li>$starts (LIKE val%, starts with)</li> <li>$ends (LIKE %val, ends with)</li> <li>$notstarts (NOT LIKE val%,don't start with)</li> <li>$notends (NOT LIKE %val,does not end with)</li> <li>$isnull (IS NULL, is NULL, doesn't accept value)</li> <li>$notnull  (IS NOT NULL, not NULL, doesn't accept value)</li> <li>$in (IN, in range, accepts multiple values \u200b\u200bseparated by commas)</li> <li>$notin (NOT IN, not in range, accepts multiple values \u200b\u200bseparated by commas)</li> <li>$between (BETWEEN, between, accepts two values)</li> <li>$notbetween (NOT BETWEEN, not between, accepts two values)</li> <li>$length (string length matching)</li> </ul>"},{"location":"usage/query_params/#filter","title":"filter","text":"<p>A fast field query method that supports multiple fields. Multiple conditions are AND</p> <p>Syntax:</p> <p>?filter=field||$operator||value</p> <p>or</p> <p>?filter=relation.field||$operator||value</p>"},{"location":"usage/query_params/#or","title":"or","text":"<p>OR conditions to the request.</p> <p>Syntax:</p> <p>?or=field||$operator||value</p> <p>or</p> <p>?or=relation.field||$operator||value</p>"},{"location":"usage/query_params/#page","title":"page","text":"<p>Current page, starting from 1</p>"},{"location":"usage/query_params/#size","title":"size","text":"<p>Pagination size per page</p> <p>Tip</p> <p>If neither page nor size is provided, the query will not be paginated.</p>"},{"location":"usage/query_params/#load","title":"load","text":"<p>Sometimes you have some relationships, but you need to load them according to the usage scenario. At this time, you need to use the Load in the query condition</p> <p><pre><code>class User(UserBase, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    user_name: str\n    hashed_password: str\n    profile_id: Optional[int] = Field(\n        default=None, foreign_key=\"user_profile.id\")\n    company_id: Optional[int] = Field(default=None, foreign_key=\"company.id\")\n    profile: UserProfile = Relationship(\n        sa_relationship_kwargs={\"uselist\": False, \"lazy\": \"noload\"})\n    tasks: List[UserTask] = Relationship(\n        sa_relationship_kwargs={\"uselist\": True,\n                                \"order_by\": \"UserTask.id.asc()\",\n                                \"cascade\": \"all, delete-orphan\",\n                                \"lazy\": \"noload\"})\n    staff: Staff = Relationship(\n        sa_relationship_kwargs={\"uselist\": False, \"lazy\": \"noload\"})\n    company: Company = Relationship(\n        sa_relationship_kwargs={\"uselist\": False, \"lazy\": \"noload\"})\n    roles: List[\"Role\"] = Relationship(back_populates=\"users\", sa_relationship_kwargs={\n                                       \"lazy\": \"noload\"}, link_model=UserRoleLink)\n    projects: List[\"Project\"] = Relationship(back_populates=\"users\", sa_relationship_kwargs={\n        \"lazy\": \"noload\"}, link_model=UserProjectLink)\n    deleted_at: Optional[datetime] = Field(\n        default=None, sa_column=Column(DateTime(timezone=True), nullable=True)\n    )\n    created_at: Optional[datetime] = Field(\n        default=None, sa_column=Column(DateTime(timezone=True), nullable=True)\n    )\n</code></pre> The user model has relationships such as profile, tasks, staff, company, roles, and projects. These relationships are not loaded by default,They are all configured with noload</p> <p>If you only want to load profile and roles in a request,You can do this</p> <p>Syntax:</p> <p>?load=profile&amp;load=roles</p>"},{"location":"usage/query_params/#join","title":"join","text":"<p>In the query, you can configure which relationships can be connected to perform joint queries</p> <p>Syntax:</p> <p>?join=profile</p> <p>Once a relationship is associated, you can use the key of the associated relationship as a prefix in your query key.</p> <pre><code>{\n    profile.name: {\n        \"$cont\":\"andy\"\n    }\n}\n</code></pre>"},{"location":"usage/query_params/#sort","title":"sort","text":"<p>add sort by field (support multiple fields) and order to query result.</p> <p>Syntax:</p> <p>?sort=field,ASC|DESC</p> <p>Examples:</p> <p>?sort=id,ASC</p> <p>or</p> <p>?sort=age,DESC</p> <p>or</p> <p>?sort=age,DESC&amp;sort=id,ASC</p>"},{"location":"usage/routing/","title":"Routing","text":"<p>The following are the routes that BetterCRUD automatically generates. You can disable and rewrite them.</p>"},{"location":"usage/routing/#default-routes","title":"Default Routes","text":"Route Method Description /resource GET Get Many /resource/{id} GET Get One /resource POST Create One /resource/bulk POST Create Many /resource/{id} PUT Update One /resource/{ids}/bulk PUT Update Many /resource/{ids} DELETE Delete Many"},{"location":"usage/routing/#disabling-routes","title":"Disabling Routes","text":""},{"location":"usage/routing/#1-globally-disable","title":"1. Globally disable","text":"<pre><code>BetterCrudGlobalConfig.init(\n    routes={\n        \"exclude\":[\"update_many\",\"create_many\"]\n    }\n)\n</code></pre>"},{"location":"usage/routing/#2-disable-in-specific-routes","title":"2. Disable in specific routes","text":"<pre><code>@crud(\n    routes={\n        \"exclude\":[\"update_many\",\"create_many\"]\n    }\n)\nclass PetController():\n    service: PetService = Depends(PetService)\n</code></pre>"},{"location":"usage/routing/#overriding-routes","title":"Overriding Routes","text":"<p>Sometimes you want to rewrite some routes</p> <pre><code>from fastapi import APIRouter, Depends\nfrom better_crud import crud\nfrom .schema import PetCreate, PetUpdate, PetPublic\nfrom .service import PetService\npet_router = APIRouter()\n@crud(\n    pet_router,\n    dto={\n        \"create\": PetCreate,\n        \"update\": PetUpdate\n    },\n    serialize={\n        \"base\": PetPublic,\n    },\n    summary_vars={\n        \"name\": \"cat\"\n    }\n)\nclass PetController():\n    service: PetService = Depends(PetService)\n\n    @pet_router.get(\"\")\n    async def override_get_many(self):\n        return []\n\n    @pet_router.get('/{id}')\n    def override_get_one(self, id: int):\n        return 'return one'\n</code></pre>"}]}